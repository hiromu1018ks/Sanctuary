# SNSアプリ「Sanctuary」機能仕様書

**作成日:** 2025年7月10日  
**バージョン:** 1.1 (改善案反映版)
**作成者:** システムエンジニア  

---

## 1. 概要

本文書は、SNSアプリ「Sanctuary」の主要機能である「AIによる投稿前レビュー機能」および「感謝の木の成長ロジック」に関する詳細な機能仕様書です。これらの機能について、エンジニアが具体的にプログラミングできるレベルまで詳細化した要件を定義します。

**関連ドキュメント:**
-   [要件定義書](./SNSアプリ「Sanctuary」要件定義書.md)
-   [開発ロードマップ](./SNSアプリ「Sanctuary」開発ロードマップ.md)

---

## 2. 感謝の木の成長ロジック (Phase 5 Post-MVP)

-   **関連機能ID:** `FUNC-012`

### 2.1 機能概要

「感謝の木」は、ユーザーが受け取った「感謝」リアクションに基づいて成長するゲーミフィケーション要素です。フォロワー数や「いいね」数に代わる新しい評価軸として、他者への貢献を可視化し、ポジティブな行動のモチベーションを高めます。

### 2.2 感謝ポイントの計算方法

#### 2.2.1 ポイント付与条件
- **基本ルール:** ユーザーの投稿に対して「感謝」（🙏）リアクションが1つ付与されるごとに、投稿者の感謝ポイントが1ポイント増加
- **リアルタイム性:** リアクション付与時点で即座にポイント加算
- **取り消し処理:** リアクション取り消し時は対応ポイントを減算

#### 2.2.2 ポイント計算ロジック (Hono想定)
```typescript
import { Hono } from 'hono';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

const app = new Hono();

app.post('/gratitude', async (c) => {
  const { userId, postId, reactorUserId } = await c.req.json();

  // 1. リアクションレコードの作成
  const reaction = await prisma.reaction.create({
    data: {
      postId: postId,
      reactorUserId: reactorUserId,
      reactedToUserId: userId,
      type: 'gratitude',
    },
  });

  // 2. ユーザーの感謝ポイントを更新
  const user = await prisma.user.update({
    where: { id: userId },
    data: {
      gratitudePoints: { increment: 1 },
    },
  });

  // 3. 成長段階の判定
  const newStage = calculateTreeStage(user.gratitudePoints);

  // 4. 成長段階が変化した場合
  if (newStage !== user.currentTreeStage) {
    await prisma.user.update({
      where: { id: userId },
      data: {
        currentTreeStage: newStage,
      },
    });
    // notificationService.sendGrowthNotification(userId, newStage);
    // 成長履歴の記録
  }

  // 5. キャッシュの更新 (Redisなどを想定)
  // await redis.set(`user:${userId}`, JSON.stringify(user));

  return c.json({ message: 'Gratitude point added successfully' });
});

function calculateTreeStage(gratitudePoints: number): string {
  if (gratitudePoints < 10) return 'seed';
  if (gratitudePoints < 30) return 'sprout';
  if (gratitudePoints < 100) return 'young_tree';
  if (gratitudePoints < 200) return 'mature_tree';
  return 'grand_tree';
}
```

### 2.3 成長段階の判定条件

#### 2.3.1 成長段階テーブル
| 感謝ポイント | 成長段階名称 | 段階ID | 視覚的特徴 |
|:-------------|:-------------|:--------|:----------|
| 0 - 9 | 種（シード） | `seed` | 小さな種の状態 |
| 10 - 29 | 芽（発芽） | `sprout` | 地面から芽が出た状態 |
| 30 - 99 | 若木 | `young_tree` | 枝が1〜2本生えた状態 |
| 100 - 199 | 成木 | `mature_tree` | 枝が3〜5本生えた状態 |
| 200以上 | 大木 | `grand_tree` | 枝が6本以上生え、実がなっている状態 |

#### 2.3.2 成長段階判定ロジック
```pseudo
function calculateTreeStage(gratitudePoints) {
    if (gratitudePoints < 10) return 'seed'
    if (gratitudePoints < 30) return 'sprout'
    if (gratitudePoints < 100) return 'young_tree'
    if (gratitudePoints < 200) return 'mature_tree'
    return 'grand_tree'
}
```

#### 2.3.3 成長通知
- 成長段階変化時に通知送信
- 通知例: 「🌱 感謝の木が『成木』に成長しました！」
- 通知タイミング: 段階変化の瞬間

### 2.4 木の視覚的な変化

#### 2.4.1 表示場所
- **プロフィール画面:** 画面幅の約30%サイズで表示
- **感謝の木詳細画面:** 画面幅の約80%サイズで詳細表示

#### 2.4.2 グラフィックアセット仕様
- **種（seed）:** 地面に埋まった/地表の小さな種
- **芽（sprout）:** 双葉が開いた状態
- **若木（young_tree）:** 細い幹、1-2本の枝
- **成木（mature_tree）:** 太い幹、3-5本の枝、豊かな葉
- **大木（grand_tree）:** 非常に大きな幹、6本以上の枝、実が生った状態

#### 2.4.3 成長アニメーション
- 成長段階変化時のトランジションアニメーション
- 拡大、枝の追加、葉の増加などの滑らかな変化
- アニメーション時間: 2-3秒程度

### 2.5 データベース設計

*詳細はPrismaスキーマ定義を参照*

### 2.6 パフォーマンス最適化案

#### 2.6.1 データベース最適化
- **インデックス戦略:**
  - `users.gratitude_points`にインデックス作成
  - `reactions(reacted_to_user_id, reaction_type)`に複合インデックス
  - `tree_growth_history(user_id, created_at)`に複合インデックス

#### 2.6.2 非同期処理
- **メッセージキューによる非同期更新:**
  - 感謝リアクション投稿時の非同期ポイント更新
  - 専用ワーカープロセスによるバックグラウンド処理
  - リアクション応答時間の短縮

#### 2.6.3 キャッシュ戦略
- **Redisキャッシュ活用:**
  - ユーザーの感謝ポイントと成長段階をキャッシュ
  - プロフィール画面での高速表示
  - ポイント更新時のキャッシュ更新

#### 2.6.4 画像アセット最適化
- **WebP形式でのファイルサイズ最適化**
- **CDN活用による配信高速化**
- **画像のプリロード戦略**

#### 2.6.5 集計処理最適化
- **バッチ処理による事前集計:**
  - 成長記録の定期的な集計
  - 統計情報のマテリアライズドビュー活用
  - リアルタイム集計負荷の軽減

#### 2.6.6 イベント駆動アーキテクチャ
- **感謝リアクション発生時のイベント発行**
- **各コンポーネントの独立処理**
- **システムの疎結合性とスケーラビリティ向上**

---

## 3. 【将来拡張仕様】AIによる投稿前レビュー機能 (Phase 5 Post-MVP)

-   **関連機能ID:** `FUNC-006`, `FUNC-007`

### 3.1 機能概要

本機能は、ユーザーが投稿（新規投稿、コメント、引用シェアコメント）を行う際に、その内容をAIがリアルタイムで分析し、Sanctuaryの理念に反する不適切な表現を検知します。検知された場合、投稿をブロックするのではなく、AIが「寄り添うコーチ」として、よりポジティブで建設的な代替表現を提案し、ユーザーが自ら表現を修正・改善する機会を提供します。

*MVP段階では、NGワードによる自動フィルタリングで代替します。以下の仕様は、個人開発のフェーズ5以降で検討するものです。*

### 3.2 検知対象の不適切な表現パターン

#### 3.2.1 誹謗中傷・個人攻撃
- 特定の個人や団体に対する直接的な侮辱、罵倒、名誉毀損、脅迫
  - **例:** 「お前は本当に役立たずだ」「〇〇は消えろ」「こんなこともできないのか、無能め」
- 容姿、能力、出自、思想などに対する差別的・攻撃的な発言
  - **例:** 「ブサイク」「頭悪い」「〇〇人だから仕方ない」

#### 3.2.2 攻撃的表現・煽り
- 他者を不快にさせる意図のある挑発的な言葉、乱暴な言葉遣い
  - **例:** 「黙れ」「ふざけるな」「お前には関係ない」
- 議論を目的とせず、感情的に相手を追い詰めるような表現
  - **例:** 「だから言っただろう」「どうせお前には理解できない」

#### 3.2.3 断定的批判・一方的な決めつけ
- 根拠なく他者の意見や行動を否定し、自身の意見を絶対視する表現
  - **例:** 「それは間違っている」「こうあるべきだ」「お前が悪い」
- 建設的な議論を阻害する、決めつけやレッテル貼り
  - **例:** 「どうせ〇〇だろう」「いつもそうだ」

#### 3.2.4 他者との比較・優劣付け
- 特定の個人やグループを不必要に引き合いに出し、優劣を付けたり、貶めたりする表現
  - **例:** 「〇〇に比べてお前は劣っている」「〇〇の方がマシ」
- 自己の優位性を示すために他者を踏み台にするような表現
  - **例:** 「私の方がずっと努力している」「こんな簡単なこともできないのか」

#### 3.2.5 過度なネガティブ表現・悲観的表現
- 過度に悲観的で、周囲に不快感を与える可能性のある表現
  - **例:** 「もう何もかも嫌だ」「生きていても意味がない」
- 自傷行為や自殺を想起させる表現（特に厳重に検知、緊急対応フローへ連携）
  - **例:** 「死にたい」「消えたい」

#### 3.2.6 スパム・宣伝・不適切なURL
- Sanctuaryの目的と異なる、過度な宣伝やスパム行為
- フィッシングサイトや違法サイトへの誘導

### 3.3 AIコーチのメッセージ例

#### 3.3.1 問題検知時の導入メッセージ
- 「✨ あなたの投稿、もう少しだけ素敵な表現にしてみませんか？AIがサポートします。」
- 「🤖 素晴らしい投稿ですね！さらに心温まる表現にするためのヒントがあります。」
- 「📝 この投稿、Sanctuaryの温かいコミュニティにぴったりにするために、AIがお手伝いできます。」

#### 3.3.2 具体的な改善提案例

**誹謗中傷・攻撃的表現に対して:**
- **元の表現:** 「あいつは本当に使えない奴だ。」
- **AIコーチ:** 「『〇〇さんは、この件で少し困っているようですね。何か手助けできることはないでしょうか？』のように、建設的な視点で伝えてみてはいかがでしょうか？」

**断定的批判に対して:**
- **元の表現:** 「このやり方は完全に間違っている。」
- **AIコーチ:** 「『このアプローチについて、私は別の視点を持っています。もしよろしければ、私の考えを共有させていただけますか？』のように、ご自身の意見として提案する形はいかがでしょうか？」

**他者との比較・優劣付けに対して:**
- **元の表現:** 「〇〇と違って、あなたは本当にダメだ。」
- **AIコーチ:** 「『〇〇さんの良い点も、あなたの良い点も、それぞれ素晴らしいですね！』のように、それぞれの良さを認め合う表現はいかがでしょうか？」

**過度なネガティブ表現に対して:**
- **元の表現:** 「もう何もかも嫌だ、生きてる意味がない。」
- **AIコーチ:** 「『今はとても辛い気持ちでいっぱいです。誰かに話を聞いてもらえたら嬉しいです。』のように、今の感情を共有しつつ、サポートを求める表現はいかがでしょうか？Sanctuaryはあなたの味方です。」

#### 3.3.3 選択肢提示
- 「提案された表現を使用しますか？」
- 「ご自身で修正されますか？（修正後、再度AIが確認します）」
- 「元の投稿に戻りますか？（投稿はキャンセルされます）」

### 3.4 検知アルゴリズムの詳細な処理フロー

#### 3.4.1 処理フロー概要
1. **投稿トリガー:** ユーザーが投稿ボタンを押下
2. **テキスト前処理:** 投稿内容の正規化とクリーニング
3. **AIモデル分析:** 外部LLM APIによる感情・トーン・キーワード分析
4. **判定処理:** 検知結果に基づく適合性判定
5. **結果処理:** 問題なしの場合は投稿完了、問題検知時は代替案提示

#### 3.4.2 技術スタック
- **基盤モデル:** OpenAI GPT-4 API
- **応答速度:** 95%のリクエストを1秒以内に処理
- **API連携:** 投稿サービスからAIレビューサービスへのRESTful API (Hono)
- **スケーラビリティ:** 同時アクセス数（初期100、成長期1,000）に対応

#### 3.4.3 詳細処理ステップ

**ステップ1: 投稿トリガー**
- ユーザーが投稿作成画面で「投稿」ボタンを押下
- コメント入力欄でコメントを確定
- 引用シェア作成画面で「投稿」ボタンを押下

**ステップ2: テキスト抽出と前処理**
- 投稿本文からテキストを抽出
- 絵文字、URL、ハッシュタグ、メンションの正規化
- 不要な空白除去、全角半角統一
- AIモデル入力形式への変換

**ステップ3: AIモデルによる分析**
- 感情分析（ポジティブ、ネガティブ、中立のスコアリング）
- トーン分析（攻撃的、批判的、煽情的、協力的など）
- キーワード・フレーズ検知
- 文脈理解による意図推測

**ステップ4: 検知結果の判定**
- 感情スコアの閾値判定
- トーン分類結果の評価
- 不適切キーワードの出現頻度チェック
- 複合的な検知パターンの評価
- 最終判定: `問題なし` または `問題検知`

**ステップ5: 後続処理の分岐**
- **問題なし:** 即座に投稿完了、データベース保存、タイムライン表示
- **問題検知:** 投稿保留、AIレビュー・代替案提示画面へ遷移

### 3.5 代替案生成の詳細

#### 3.5.1 代替案生成プロセス
1. **入力準備:** 検知された投稿テキストと問題パターン
2. **LLMリクエスト:** 専用プロンプトによる代替案生成
3. **結果処理:** 生成された代替案の後処理と表示

#### 3.5.2 プロンプト構成例
```
あなたはSNSアプリ「Sanctuary」のAIコーチです。ユーザーが投稿しようとしている以下の文章には、Sanctuaryの理念に反する不適切な表現が含まれている可能性があります。
あなたの役割は、ユーザーを批判するのではなく、寄り添いながら、よりポジティブで建設的な表現に言い換える代替案を提案することです。

元の文章: 「[元の投稿テキスト]」

不適切と判断された理由（参考情報）: [検知された不適切パターンの種類]

以下の制約を守って、代替案を1つ提案してください。
- ポジティブで、相手を尊重する表現にすること
- 建設的な意見や感情を伝える形にすること
- 攻撃的、批判的、断定的な言葉遣いを避けること
- ユーザーの意図を汲み取りつつ、Sanctuaryのコンセプト（感謝、応援、共感）に沿うようにすること
- 自然な日本語であること
- 元の文章と大きく意味が変わらない範囲で、表現を改善すること

代替案:
```

#### 3.5.3 APIパラメータ設定
- `temperature`: 0.7-0.9（創造性を許容しつつ逸脱を防ぐ）
- `max_tokens`: 適切な長さの代替案生成用に調整
- `top_p`, `frequency_penalty`, `presence_penalty`: 自然で多様な代替案生成

### 3.6 非機能要件

#### 3.6.1 性能要件
- **応答速度:** 95%のリクエストを1秒以内に処理
- **スケーラビリティ:** 同時アクセス数（初期100、成長期1,000）対応
- **信頼性:** 外部API障害時のフォールバック戦略

#### 3.6.2 運用・保守要件
- **AIモデル改善:** 四半期に一度の再学習と評価
- **教師データ活用:** 人間モデレーターのフィードバック活用
- **パターン更新:** 不適切表現パターンの定期見直し

### 3.7 外部API障害時の対応策

#### 3.7.1 障害シナリオと影響度

OpenAI GPT-4 APIに依存するAIレビュー機能の障害シナリオとその影響度を以下に定義します。

| 障害レベル | 状況 | 影響度 | 対応策 |
|:------------|:-----|:--------|:--------|
| レベル1 | API応答避延（>2秒） | 低 | キャッシュ活用、リトライ機構 |
| レベル2 | 部分的サービス障害 | 中 | キューイング、限定適用 |
| レベル3 | 完全サービス停止 | 高 | フォールバックモード、手動レビュー |
| レベル4 | 長期間サービス停止 | 極高 | 代替AIモデル、システム変更 |

#### 3.7.2 GPT-4 API障害時のフォールバック戦略

**キャッシュ活用戦略**
- **Redisキャッシュ連携:** 過去のAIレビュー結果をハッシュ化してキャッシュ保存
- **キャッシュキー設計:** `ai_review:{content_hash}` 形式
- **TTL設定:** 24時間（一日あたりのユニーク投稿を考慮）
- **キャッシュヒット率:** 30-40%を目標

**段階的な機能制限**
```pseudo
function handleApiFailure(failureLevel) {
    switch(failureLevel) {
        case 'LEVEL_1': // 応答避延
            enableCaching()
            increaseRetryInterval()
            break
            
        case 'LEVEL_2': // 部分的障害
            enableQueueProcessing()
            limitConcurrentRequests(maxConcurrent: 5)
            showDelayNotification()
            break
            
        case 'LEVEL_3': // 完全停止
            enableFallbackMode()
            disableAiReview()
            enableManualReview()
            showMaintenanceNotification()
            break
            
        case 'LEVEL_4': // 長期停止
            switchToAlternativeAI()
            enableRuleBasedCheck()
            notifyAdministrators()
            break
    }
}
```

**代替AIモデルの利用**
- **プライマリ:** OpenAI GPT-4
- **セカンダリ:** Google Gemini Pro API
- **ターシャリ:** Anthropic Claude API
- **緊急時:** ルールベースチェック

**ユーザーへの適切な通知**
- **避延時:** 「現在AIコーチが少し遅いです。しばらくお待ちください。」
- **機能制限時:** 「現在AIコーチはメンテナンス中です。一時的に簡易チェックのみとなります。」
- **完全停止時:** 「現在AIコーチは休憩中です。投稿後に運営チームが確認いたします。」

#### 3.7.3 レート制限対応の最適化

**非同期処理とキューイング**
- **Redisキュー管理:** 投稿レビューリクエストをキューに格納
- **優先度制御:** 新規ユーザー < 一般ユーザー < VIPユーザー
- **同時処理数制限:** 最大10件までの同時API呼び出し
- **バックプレッシャー対応:** キュー満杉時の新規投稿エラーハンドリング

**バッチ処理の検討**
- **バッチサイズ:** 5-10件の投稿を一度に処理
- **適用条件:** 同一ユーザーの連続投稿時
- **コスト削減:** API呼び出し回数の20-30%削減を目標

**リトライ機構**
- **指数バックオフ:** 初回1秒、最大30秒まで待機
- **最大リトライ回数:** 3回
- **リトライ対象エラー:** ネットワークエラー、タイムアウト、レート制限

#### 3.7.4 代替手段

**ルールベースの簡易チェック**
- **ネガティブキーワードチェック:** 事前定義された禁止語句のパターンマッチング
- **文体解析:** 攻撃的な言回しや命令形の検出
- **長さ制限:** 投稿内容の最大文字数チェック
- **URLチェック:** スパムや悪意あるURLのブラックリストチェック

**人手によるレビューへの切り替え**
- **対象:** AIチェックで「問題あり」と判定された投稿
- **キュー:** 「手動レビュー待ち」キューに移動
- **SLA:** 3時間以内に人間モデレーターがチェック
- **通知:** 「現在運営チームが投稿を確認中です。しばらくお待ちください。」

**一時的な投稿制限**
- **制限レベル1:** 新規ユーザーのみ投稿制限
- **制限レベル2:** 全ユーザーの投稿を一時停止（閲覧のみ可能）
- **制限レベル3:** 緊急メンテナンスモード（全機能停止）

#### 3.7.5 監視とアラート

**API状態の監視**
- **ヘルスチェック間隔:** 30秒ごとのAPI応答時間チェック
- **エラー闾値:** 5回連続エラーでアラート発生
- **応答時間闾値:** 2秒以上で警告、定期レポート作成

**障害検知とアラート**
- **監視項目:**
  - API応答時間（目標: <1秒、警告: >2秒、アラート: >5秒）
  - APIエラー率（目標: <1%、警告: >5%、アラート: >10%）
  - キューサイズ（警告: >100件、アラート: >500件）

- **アラート通知先:**
  - Slackチャンネル: #sanctuary-alerts
  - メール: dev-team@sanctuary.app
  - PagerDuty（緊急時）

**自動復旧機構**
- **レート制限復旧:** APIレート制限リセットの待機
- **バックアップエンドポイント:** ネットワークエラー時の自動切り替え
- **定期復旧チェック:** 5分ごとのサービス復旧確認

---

## 4. 実装上の注意事項

### 4.1 AIレビュー機能
- 外部API（OpenAI GPT-4）の障害時フォールバック戦略の実装（上記セクション3.7参照）
- レート制限対応とAPIキーの適切な管理
- AIモデルの精度向上のための継続的な学習データ収集
- 代替AIモデル（Gemini Pro、Claude）の統合準備
- キューイングシステムの堅牢性確保
- Honoのミドルウェアとバリデーションの活用

### 4.2 感謝の木機能
- 大量のリアクションが同時発生した場合の整合性確保
- 成長段階変化時の通知処理の重複防止
- 視覚的アニメーションのパフォーマンス最適化

### 4.3 セキュリティ
- APIキーの安全な管理
- ユーザー入力のサニタイゼーション
- 不正リアクションの検出と防止

### 4.4 モニタリング
- AIレビューの応答時間監視
- 感謝ポイント計算の正確性監視
- エラーログの収集と分析

---

## 5. 承認

**承認者欄:**
- プロダクトオーナー: ________________
- 開発責任者: ________________
- システムアーキテクト: ________________

**承認日:** 20xx年xx月xx日

---

*本文書は、開発プロジェクトの進行に伴い更新される場合があります。*